<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="">
    <title>PolyMixin Docs</title>
    <script type="module" src="ui.js" defer></script>
    <link href="./output.css" rel="stylesheet">
</head>

<body class="bg-slate-800 text-white">

<div class="md:flex min-h-screen">
    <aside class="bg-slate-900 md:flex flex-col sticky top-0 h-screen p-4 transform -translate-x-full md:translate-x-0 hidden md:translate-visible transition-transform duration-300">
        <div class="px-4 border-b border-slate-600 h-16 flex justify-center items-center font-bold bg-slate-900 z-10 sticky top-0">
            PolyMixin Documentation
        </div>

        <div class="flex-1 overflow-y-auto mt-2">
            <ul id="sidebar" class="space-y-2 px-4"></ul>
        </div>
    </aside>

    <main class="flex-1 py-8 md:px-16 px-6 md:pr-24 overflow-x-hidden" id="content">
        <button id="sidebar-toggle" class="md:hidden mb-4 px-3 py-2 bg-slate-700 text-white rounded">Menu</button>
        <h1 class="text-3xl font-bold mb-4">Welcome to PolyMixins Documentation</h1>
        <p>Select a topic from the sidebar to see its content.</p>
    </main>
</div>

<script>
    const sidebar = document.getElementById('sidebar');
    const content = document.getElementById('content');

    const entries = [
        {
            id: 'getting-started',
            title: 'Getting Started',
            content: `
<div class="flex flex-col gap-5">
               <p class="text-3xl font-bold mb-2">Understanding PolyMixin</p>

               <p class="text-2xl font-bold">What is PolyMixin ?</p>
               <p class="mb-4"><strong>PolyMixin</strong> is a <strong>framework and API</strong> for V-Slice mods, built on <doc-link href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</doc-link> manipulation.
It is inspired by the mixin pattern used in projects like SpongePowered Mixin (Minecraft), and allows modders to patch or extend scripted classes without modifying their original scripts.</p>

               <p class="text-2xl font-bold">How does it work ?</p>
               <p>PolyMixin hooks into Polymod's scripting system by using the <code-field>PolymodScriptClass</code-field>(<code-field>_abs</code-field>) and modifying the <code-field>_cachedFunctionDecls</code-field> and <code-field>_cachedFieldDecls</code-field>.
               It replaces or transforms the function declarations (<code-field>FunctionDecl</code-field>) using the function declaration from another class, which is also a <code-field>PolymodScriptClass</code-field>.</p>
               <p class="mb-4">Think of it as "hot-swapping" functions at the AST level.</p>

               <p class="text-2xl font-bold">Limitations ?</p>
               <p>Currently, there are some limitations:</p>
               <ul class="list-disc ml-6 mb-4">
                 <li>Some transformations are applied later, because mixins may load before or after the base class (always check for PolyMixin and the original module’s availability before using it).</li>
                 <li>Lack of testing in actual mods use cases, so behavior may be unpredictable.</li>
               </ul>
</div>
`,
            subsections: []
        },
        {
            id: 'setup',
            title: 'Setting up PolyMixins',
            content: `
<div class="flex flex-col gap-5">
               <p class="text-2xl font-bold">Preparation</p>
               <p>Before you start to use <strong>PolyMixins</strong>, you should have a basic understanding of scripting in V-Slice and how it works.</p>
               <div>
                 <p>If you are new to V-Slice modding, you may want to check out documentation and tutorials first.</p>
                 <p>Here are some resources to get you started:</p>
               </div>
               <ul class="list-disc ml-6 mb-4 font-bold">
                 <li><doc-link href="https://funkincrew.github.io/funkin-modding-docs/">Friday Night Funkin' Modding Documentation</doc-link></li>
                 <li><doc-link href="https://thekade.net/funkin-cookbook/">Friday Night Funkin' Cookbook</doc-link></li>
                 <li><doc-link href="https://polymod.io/docs/">Polymod Documentation</doc-link></li>
                 <li><doc-link href="https://haxe.org/documentation/introduction/">Haxe Documentation</doc-link></li>
               </ul>

              <p class="text-2xl font-bold">Installation</p>
              <p>
               To use <strong>PolyMixin</strong> in your project, make sure it is installed as a <strong>mod</strong> inside your Friday Night Funkin' mods folder.
               PolyMixin should be placed alongside your other mods so that it can patch and extend scripts during runtime.
              </p>
              <p>You can download PolyMixin from:</p>
              <ul class="list-disc ml-6 font-bold">
                <li><doc-link href="https://github.com/Starexify/PolyMixin/tree/main">Official GitHub Repo</doc-link></li>
              </ul>
              <p class="mb-4">After installing, verify that PolyMixin loads correctly before attempting to use any mixin features in your own mods.</p>

              <p class="text-2xl font-bold">Configuration</p>
              <p>Now moving to the juicy stuff, configuration.
              PolyMixin gives you the possibility to add your own configuration for mixins to load when the game starts and after hot reloads.
              </p>
              <div>
                <p>First you need a mixin configuration file. <span class="text-red-700 font-bold">Important!</span> <strong>The file should be placed in <code-field>mods/YourMod/_polymixin_config.json</code-field></strong></p>
                <p>An example of how a configuration file can look like:</p>
              </div>
              <code-block language="json">
{
  "mixins": [
    { "className": "ExampleSongMixin", "kind": "Song", "params": { "id": "testing", "variation": "default" } },
    { "className": "ExampleModuleMixin", "kind": "Mixin" },
    "BoyfriendMixin"
  ]
}
              </code-block>
              <p>After adding the configuration file all you need to do for this is add this line in the <code-field>onCreate</code-field> event:</p>
              <code-block language="haxe">
override public function onCreate(event:ScriptEvent) {
    Mixins.addConfig("ModID"); // The ModID is the path to your mod's folder, for example "PolyMixin"
}
              </code-block>
              <p>For more information about configuration, check out the <doc-link href="#classes:mixins" target-off>Mixins</doc-link> class.</p>
</div>
`,
            subsections: []
        },
        {
            id: 'annotations',
            title: 'Annotations',
            content: `<note-block>Annotations only work if you use a polymixin config file or handle them yourself using the MixinAnnotationProcessor.</note-block>`,
            subsections: [
                {
                    id: 'overwrite',
                    title: '@:Overwrite',
                    content: `
<div class="flex flex-col gap-2">
                    <p>There are many ways to overwrite functions using mixins, and one of them is by using the <code-field>@:Overwrite</code-field> annotation.</p>
                    <p>So let's take for example the following snippet of a script:</p>
                    <code-block language="haxe">
public function test() {
    trace("test() called");
}
                    </code-block>
                    <p>If you need to overwrite that function here is an example of what you can write in your own <doc-link href="#examples:mixin-class" target-off>Mixin Class</doc-link>:</p>
                    <code-block language="haxe">
@:Overwrite(method = "test")
function testOverwrite() {
    trace("Overwrote test()");
}
                    </code-block>
</div>
                    `
                },
                {
                    id: 'inject',
                    title: '@:Inject',
                    content: `
<div class="flex flex-col gap-2">
                    <p>There are many ways to inject into functions using mixins, and one of them is by using the <code-field>@:Inject</code-field> annotation.</p>
                    <p class="mb-4">But choose carefully because there are many types of injection such as:</p>

                    <div class="flex flex-col space-y-3">
                      <p class="font-bold text-xl">Injecting at the HEAD of a function</p>
                      <p>So let's take for example the following snippet of a script:</p>
                      <code-block language="haxe">
public function test() {
    trace("test() called");
}
                      </code-block>
                      <p>If you need to inject code into that function at the beginning here is an example of what you can write in your own <doc-link href="#examples:mixin-class" target-off>Mixin Class</doc-link>:</p>
                      <code-block language="haxe">
@:Inject(method = "test", at = "HEAD")
function testInject() {
    trace("Injected into test() at HEAD");
}
                      </code-block>
                      <p>The function would look like this after the injection:</p>
                      <code-block language="haxe">
public function test() {
    trace("Injected into test() at HEAD");
    trace("test() called");
}
                      </code-block>

                      <p class="font-bold text-xl mt-4">Injecting at the RETURN of a function</p>
                      <p>Now let's take another example:</p>
                      <code-block language="haxe">
public function test() {
    doSomething();
    return trace("Test Return");
}
                      </code-block>
                      <p>If you need to inject code into that function before the return here is an example of what you can write in your own <doc-link href="#examples:mixin-class" target-off>Mixin Class</doc-link>:</p>
                      <code-block language="haxe">
@:Inject(method = "test", at = "RETURN")
function testInject() {
    trace("Injected into test() at RETURN");
}
                      </code-block>
                      <p>The function would look like this after the injection:</p>
                      <code-block language="haxe">
public function test() {
    doSomething();
    trace("Injected into test() at RETURN");
    return trace("Test Return");
}
                      </code-block>

                      <p class="font-bold text-xl mt-4">Injecting at a target inside the function using INVOKE</p>
                      <p>And the last example:</p>
                      <code-block language="haxe">
public function test() {
    trace("test() called");
    doSomething();
    doSomething();
    trace("test() called x2");
}
                      </code-block>
                      <p>If you need to inject code into that function before doSomething() here is an example of what you can write in your own <doc-link href="#examples:mixin-class" target-off>Mixin Class</doc-link>:</p>
                      <code-block language="haxe">
@:Inject(method = "test", at = "INVOKE", target = "doSomething")
function testInject() {
    trace("Injected into test() before doSomething()");
}
                      </code-block>
                      <p>The function would look like this after the injection:</p>
                      <code-block language="haxe">
public function test() {
    trace("test() called");
    trace("Injected into test() before doSomething()");
    doSomething();
    doSomething();
    trace("test() called x2");
}
                      </code-block>

                      <tip-block>
                        Injection behavior depends on the annotation parameters you use.
                        <p class="text-gray-400 text-sm">See <doc-link href="#injection-params" target-off>Injection Parameters</doc-link> for more information.</p>
                      </tip-block>
                    </div>
</div>
                    `
                },
                {
                    id: 'modify-return',
                    title: '@:ModifyReturn',
                    content: `
<div class="flex flex-col gap-2">
                    <p>There are many ways to modify the return call of a function using mixins, and one of them is by using the <code-field>@:ModifyReturn</code-field> annotation.</p>
                    <p>Let's take for example the following snippet of a script:</p>
                    <code-block language="haxe">
public function test() {
    return 20;
}
                    </code-block>
                    <p>If you need to modify the return call of that function here is an example of what you can write in your own <doc-link href="#examples:mixin-class" target-off>Mixin Class</doc-link>:</p>
                    <code-block language="haxe">
@:ModifyReturn(method = "test", call = testReturnCall)
function testReturn(original:Int) {
    return original + 10;
}

function testReturnCall(original:Int) {
    testReturn(original);
}
                    </code-block>

                    &nbsp;
                    <note-block>The Call function is required for the modified return to work !</note-block>
                    <p></p>
                    <p>And the function would look like this after the modification:</p>
                    <code-block language="haxe">
public function test() {
    return testReturnCall(20 + 10);
}
                    </code-block>
</div>
                    `
                },
                {
                    id: 'modify-expression',
                    title: '@:ModifyExpression',
                    content: `
<div class="flex flex-col gap-2">
                    <p>There are many ways to modify the expression call of a function using mixins, and one of them is by using the <code-field>@:ModifyExpression</code-field> annotation.</p>
                    <p>Let's take for example the following snippet of a script:</p>
                    <code-block language="haxe">
public function test() {
    if (true) trace(true);
    if (false) trace(false);
    if (true) trace("true x2");
    if (true) trace("true x3");
}
                    </code-block>
                    <p>If you need to modify the return call of that function here is an example of what you can write in your own <doc-link href="#examples:mixin-class" target-off>Mixin Class</doc-link>:</p>
                    <code-block language="haxe">
@:ModifyExpression(method = "test", call = testExprCall, target = true, ordinal = 0)
function testExpr(original:Bool) {
    return false;
}

function testExprCall(original:Bool) {
    testExpr(original);
}
                    </code-block>

                    &nbsp;
                    <note-block>The Call function is required for the modified expression to work !</note-block>
                    <p></p>
                    <p>And the function would look like this after the modification:</p>
                    <code-block language="haxe">
public function test() {
    if (testExprCall(testExpr(true))) trace(true);
    if (false) trace(false);
    if (true) trace("true x2");
    if (true) trace("true x3");
}
                    </code-block>
                    <tip-block>
                      Injection behavior depends on the annotation parameters you use.
                      <p class="text-gray-400 text-sm">See <doc-link href="#injection-params" target-off>Injection Parameters</doc-link> for more information.</p>
                    </tip-block>
</div>
                    `
                },
                {
                    id: 'inject-function',
                    title: '@:InjectFunction',
                    content: `
<div class="flex flex-col gap-2">
                    <p>There are many ways to inject a function using mixins, and one of them is by using the <code-field>@:InjectFunction</code-field> annotation.</p>
                    <p>So let's take for example you need a function inside a class, here is an example of what you can write in your own <doc-link href="#examples:mixin-class" target-off>Mixin Class</doc-link> for that:</p>
                    <code-block language="haxe">
@:InjectFunction
function newTest() {
    trace("newTest() function injected");
}
                    </code-block>
                    <p>The class would now have this function and can be used:</p>
                    <code-block language="haxe">
function newTest() {
    trace("newTest() function injected");
}
                     </code-block>
</div>
                    `
                }
            ]
        },
        {
            id: 'injection-params',
            title: 'Injection Parameters',
            content: `(WIP)`,
            subsections: []
        },
        {
            id: 'classes',
            title: 'Classes',
            content: ``,
            subsections: [
                {
                    id: 'polymixin',
                    title: 'PolyMixin',
                    content: `(WIP)`
                },
                {
                    id: 'mixin-annotation-proc',
                    title: 'MixinAnnotationProcessor',
                    content: `(WIP)`
                },
                {
                    id: 'mixins',
                    title: 'Mixins',
                    content: `(WIP)`
                }
            ]
        },
        {
            id: 'examples',
            title: 'Examples',
            content: ``,
            subsections: [
                {
                    id: 'mixin-class',
                    title: 'Mixin Classes',
                    content: `(WIP)`
                }
            ]
        }
    ];

    // Populate sidebar with entries
    const links = {};
    const flatEntries = [];
    entries.forEach(entry => {
        const li = document.createElement('li');

        const button = document.createElement('button');
        button.className = "flex items-center justify-between w-full text-left text-gray-400 hover:text-blue-500 py-2 transition-colors font-medium hover:cursor-pointer";
        button.textContent = entry.title;

        li.appendChild(button);

        if (entry.subsections.length) {
            // Create transitionable arrow
            const arrow = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            arrow.setAttribute("class", "w-3 h-3 transition-transform duration-200 -rotate-90");
            arrow.setAttribute("viewBox", "0 0 10 6");
            arrow.setAttribute("fill", "none");
            arrow.innerHTML = `<path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M1 1l4 4 4-4"/>`;
            button.appendChild(arrow);

            const subUl = document.createElement('ul');
            subUl.className = "ml-4 space-y-2 hidden";

            entry.subsections.forEach(sub => {
                const subLi = document.createElement('li');
                const subLink = document.createElement('a');
                subLink.href = `#${entry.id}:${sub.id}`;
                subLink.textContent = sub.title;
                subLink.className = "block text-gray-400 hover:text-blue-500 text-sm";
                subLi.appendChild(subLink);
                subUl.appendChild(subLi);
                links[`${entry.id}:${sub.id}`] = subLink;
            });

            li.appendChild(subUl);

            button.addEventListener('click', () => {
                const isHidden = subUl.classList.contains('hidden');
                subUl.classList.toggle('hidden');

                // Toggle arrow rotation: closed (-rotate-90) <-> open (rotate-0)
                if (isHidden) {
                    arrow.classList.remove('-rotate-90');
                    arrow.classList.add('rotate-0');
                } else {
                    arrow.classList.remove('rotate-0');
                    arrow.classList.add('-rotate-90');
                }
            });
        } else {
            button.addEventListener('click', () => {
                window.location.hash = entry.id;
            });
        }

        sidebar.appendChild(li);
        links[entry.id] = button;
        if (entry.subsections.length > 0) entry.subsections.forEach(sub => {
            flatEntries.push({id: `${entry.id}:${sub.id}`, title: sub.title});
        });
        else flatEntries.push({id: entry.id, title: entry.title});
    });

    // Load an entry by ID
    function loadEntry(hash) {
        if (!hash) return;

        const [sectionId, subsectionId] = hash.split(':');
        const section = entries.find(e => e.id === sectionId);
        if (!section) return;

        let html = `<h1 class="text-4xl font-bold pb-8">${section.title}</h1>
                <hr class="border-slate-600 mb-6">
                ${section.content}`;

        if (subsectionId) {
            const sub = section.subsections.find(s => s.id === subsectionId);
            if (sub) html += `<h2 class="text-2xl font-bold mt-10 mb-3">${sub.title}</h2>${sub.content}`;
        }

        html += `<div class="flex justify-center mt-8 md:mx-10 gap-4">
            <button id="prevSection" class="flex-1 flex flex-col items-start min-w-0 border border-slate-600 hover:border-blue-500 py-2 px-4 rounded-xl hover:cursor-pointer disabled:opacity-0">
                <span class="text-sm font-semibold">← Previous</span>
                <span id="prevId" class="text-blue-500 mt-1 truncate block max-w-full"></span>
            </button>
            <button id="nextSection" class="flex-1 flex flex-col items-end min-w-0 border border-slate-600 hover:border-blue-500 py-2 px-4 rounded-xl hover:cursor-pointer disabled:opacity-0">
                <span class="text-sm font-semibold">Next →</span>
                <span id="nextId" class="text-blue-500 mt-1 truncate block max-w-full"></span>
            </button>
        </div>`;

        content.innerHTML = html;

        // Highlight section
        Object.values(links).forEach(link => {
            link.classList.remove('text-blue-600', 'font-bold');
            link.classList.add('text-gray-400');
        });

        const activeLink = links[hash] || links[sectionId];
        if (activeLink) {
            activeLink.classList.add('text-blue-600', 'font-bold');
            activeLink.classList.remove('text-gray-400');
        }

        // Open parent section if subsection is active
        if (subsectionId) {
            const parentUl = activeLink.closest('ul');
            if (parentUl) {
                parentUl.classList.remove('hidden');

                // Make sure arrow points down when opened
                const parentButton = parentUl.previousElementSibling;
                const arrowSvg = parentButton.querySelector('svg');
                if (arrowSvg) {
                    arrowSvg.classList.remove('-rotate-90');
                    arrowSvg.classList.add('rotate-0');
                }
            }
        }

        const index = flatEntries.findIndex(e => e.id === hash);
        const prevBtn = document.getElementById('prevSection');
        const nextBtn = document.getElementById('nextSection');
        const prevIdSpan = document.getElementById('prevId');
        const nextIdSpan = document.getElementById('nextId');

        if (index > 0) {
            prevBtn.disabled = false;
            prevIdSpan.textContent = flatEntries[index - 1].title;
            prevBtn.onclick = () => window.location.hash = flatEntries[index - 1].id;
        } else {
            prevBtn.disabled = true;
            prevIdSpan.textContent = '';
        }

        if (index < flatEntries.length - 1) {
            nextBtn.disabled = false;
            nextIdSpan.textContent = flatEntries[index + 1].title;
            nextBtn.onclick = () => window.location.hash = flatEntries[index + 1].id;
        } else {
            nextBtn.disabled = true;
            nextIdSpan.textContent = '';
        }
    }

    // Load entry when hash changes
    window.addEventListener('hashchange', () => loadEntry(window.location.hash.substring(1)));
    if (window.location.hash) loadEntry(window.location.hash.substring(1));
</script>

</body>
</html>